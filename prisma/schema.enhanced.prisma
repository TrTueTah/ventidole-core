// =============================================================================
// Ventidole Core - Enhanced Database Schema
// =============================================================================
// This schema combines authentication, social features, and moderation
// optimized for mobile apps with real-time features
//
// Architecture:
// - PostgreSQL: User accounts, relationships, settings (this file)
// - Firebase: Posts, comments, feeds, real-time data (see Firestore docs)
// =============================================================================

generator client {
  provider = "prisma-client"
  output   = "../src/db/prisma"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// =============================================================================
// CORE AUTHENTICATION
// =============================================================================

model Account {
  id              String          @id @default(cuid())
  isActive        Boolean         @default(true)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  version         Int             @default(0)
  
  // Authentication
  email           String          @unique @db.VarChar(255)
  phoneNumber     String?         @db.VarChar(255)
  password        String          @db.VarChar(255)
  role            Role
  
  // Profile Information
  name            String?         @db.VarChar(255)
  username        String?         @unique @db.VarChar(50)
  bio             String?         @db.VarChar(500)
  avatarUrl       String?         @db.VarChar(500) @map("avatar_url")
  coverUrl        String?         @db.VarChar(500) @map("cover_url")
  dateOfBirth     DateTime?       @map("date_of_birth")
  location        String?         @db.VarChar(255)
  website         String?         @db.VarChar(500)
  
  // Status & Activity
  isOnline        Boolean         @default(false) @map("is_online")
  isDeleted       Boolean         @default(false) @map("is_deleted")
  isVerified      Boolean         @default(false) @map("is_verified")
  lastSeenAt      DateTime?       @map("last_seen_at")
  
  // Device & Notifications
  deviceToken     String?         @db.VarChar(255) @map("device_token")
  
  // Statistics (denormalized for performance)
  followersCount  Int             @default(0) @map("followers_count")
  followingCount  Int             @default(0) @map("following_count")
  postsCount      Int             @default(0) @map("posts_count")
  
  // Relations
  socialAccounts  SocialAccount[]
  verifications   Verification[]
  following       Follow[]        @relation("UserFollowing")
  followers       Follow[]        @relation("UserFollowers")
  blockedUsers    Block[]         @relation("BlockedBy")
  blockedBy       Block[]         @relation("Blocked")
  settings        UserSettings?
  reports         Report[]        @relation("Reporter")
  reportedIn      Report[]        @relation("Reported")

  @@index([username])
  @@index([email])
  @@index([isActive, isDeleted])
  @@index([isOnline])
  @@map("accounts")
}

// =============================================================================
// VERIFICATION SYSTEM
// =============================================================================

model Verification {
  id          String           @id @default(cuid())
  isActive    Boolean          @default(true)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  version     Int              @default(0)
  type        VerificationType
  token       String           @unique
  expiresAt   DateTime         @map("expires_at")
  accountId   String?          @map("account_id")
  usedAt      DateTime?        @map("used_at")
  confirmedAt DateTime?        @map("confirmed_at")
  email       String?          @db.VarChar(255)
  account     Account?         @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([accountId])
  @@index([expiresAt])
  @@map("verifications")
}

// =============================================================================
// SOCIAL AUTHENTICATION
// =============================================================================

model SocialAccount {
  id         String                @id @default(cuid())
  isActive   Boolean               @default(true)
  createdAt  DateTime              @default(now())
  updatedAt  DateTime              @updatedAt
  version    Int                   @default(0)
  provider   SocialAccountProvider
  providerId String                @map("provider_id")
  accountId  String                @map("account_id")
  account    Account               @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([provider, providerId])
  @@index([accountId])
  @@map("social_accounts")
}

// =============================================================================
// SOCIAL FEATURES
// =============================================================================

model Follow {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  
  followerId  String   @map("follower_id")
  followingId String   @map("following_id")
  
  follower    Account  @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  following   Account  @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@index([createdAt])
  @@map("follows")
}

model Block {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  
  blockerId   String   @map("blocker_id")
  blockedId   String   @map("blocked_id")
  reason      String?  @db.VarChar(500)
  
  blocker     Account  @relation("BlockedBy", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked     Account  @relation("Blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
  @@map("blocks")
}

// =============================================================================
// USER SETTINGS
// =============================================================================

model UserSettings {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  accountId String   @unique @map("account_id")
  account   Account  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  
  // Privacy Settings
  isPrivate         Boolean @default(false) @map("is_private")
  allowTagging      Boolean @default(true) @map("allow_tagging")
  allowComments     Boolean @default(true) @map("allow_comments")
  showOnlineStatus  Boolean @default(true) @map("show_online_status")
  
  // Notification Settings
  emailNotifications Boolean @default(true) @map("email_notifications")
  pushNotifications  Boolean @default(true) @map("push_notifications")
  likeNotifications  Boolean @default(true) @map("like_notifications")
  commentNotifications Boolean @default(true) @map("comment_notifications")
  followNotifications Boolean @default(true) @map("follow_notifications")
  
  // Content Settings
  language          String  @default("en") @db.VarChar(10)
  theme             String  @default("light") @db.VarChar(20)

  @@map("user_settings")
}

// =============================================================================
// MODERATION & REPORTING
// =============================================================================

model Report {
  id          String       @id @default(cuid())
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  
  // Reporter
  reporterId  String       @map("reporter_id")
  reporter    Account      @relation("Reporter", fields: [reporterId], references: [id], onDelete: Cascade)
  
  // Reported User (optional - null if reporting content)
  reportedId  String?      @map("reported_id")
  reported    Account?     @relation("Reported", fields: [reportedId], references: [id], onDelete: Cascade)
  
  // Content Information
  contentType ContentType  @map("content_type")
  contentId   String       @map("content_id") // Firebase document ID
  
  // Report Details
  reason      ReportReason
  description String?      @db.VarChar(1000)
  status      ReportStatus @default(PENDING)
  
  // Resolution
  reviewedBy  String?      @map("reviewed_by") // Admin account ID
  reviewedAt  DateTime?    @map("reviewed_at")
  resolution  String?      @db.VarChar(500)

  @@index([reporterId])
  @@index([reportedId])
  @@index([status])
  @@index([createdAt])
  @@index([contentType, contentId])
  @@map("reports")
}

// =============================================================================
// ENUMS
// =============================================================================

enum Role {
  FAN
  ADMIN
  IDOL
}

enum VerificationType {
  FIND_EMAIL
  RESET_PASSWORD
  REGISTER_ACCOUNT
  UPDATE_PROFILE
}

enum SocialAccountProvider {
  GOOGLE
  FACEBOOK
  APPLE
}

enum ContentType {
  POST
  COMMENT
  USER
  MESSAGE
}

enum ReportReason {
  SPAM
  HARASSMENT
  INAPPROPRIATE_CONTENT
  VIOLENCE
  HATE_SPEECH
  FALSE_INFORMATION
  COPYRIGHT
  IMPERSONATION
  OTHER
}

enum ReportStatus {
  PENDING
  REVIEWING
  RESOLVED
  DISMISSED
}

// =============================================================================
// NOTES & BEST PRACTICES
// =============================================================================
//
// 1. Use PostgreSQL for:
//    - User accounts & authentication
//    - Relationships (follow, block)
//    - User settings
//    - Moderation (reports)
//
// 2. Use Firebase for:
//    - Posts & comments (high volume)
//    - Likes & reactions (real-time)
//    - User feeds
//    - Notifications
//    - Chat messages
//
// 3. Denormalization:
//    - Store user stats in Account table (followers, posts count)
//    - Update via transactions when changes occur
//    - Background jobs for consistency checks
//
// 4. Indexes:
//    - All foreign keys are indexed automatically
//    - Add composite indexes for common queries
//    - Monitor query performance in production
//
// 5. Migration Commands:
//    npx prisma migrate dev --name add_social_features
//    npx prisma generate
//
// =============================================================================
